<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ashley Arthur</title><link href="http://ashleyarthur.co.uk/" rel="alternate"></link><link href="http://ashleyarthur.co.uk/feeds/all.atom.xml" rel="self"></link><id>http://ashleyarthur.co.uk/</id><updated>2017-05-02T00:00:00+02:00</updated><entry><title>HueInspired - an iOS App Post Mortem</title><link href="http://ashleyarthur.co.uk/hueinspired-an-ios-app-post-mortem.html" rel="alternate"></link><published>2017-05-02T00:00:00+02:00</published><updated>2017-05-02T00:00:00+02:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2017-05-02:hueinspired-an-ios-app-post-mortem.html</id><summary type="html">&lt;p&gt;My current project is “HueInspired” - an iOS app for color palette generation from photos and I’m coming close to completing v1.0. Its been a blast and as a form of catharsis / chance to share what I learnt, I’m here to coherently ramble about the interesting points of the journey.&lt;/p&gt;
&lt;h3&gt;Swinject&lt;/h3&gt;
&lt;p&gt;In the initial prototype of the app I did my dependency injection manually through a combination of initialiser injection and pass through parameters. It worked but there was a lot of boiler plate that I had to maintain and it also conflated ownership as it required some classes to hold additional dependencies purely to pass it to constructors at runtime.&lt;/p&gt;
&lt;p&gt;Swinject definitely cleaned up the boilerplate, centralising construction in container callbacks and through its storyboard extension helped remove any hardcoding in the view controllers. I really liked the fact singletons became implementation detail of the class rather than the calling code, helping to keep things testable.&lt;/p&gt;
&lt;p&gt;The down side was I faced a lot of implicitly unwrapped optionals in said callbacks which makes me uneasy. It almost feels like you should include the Swinject container in your test coverage just to make sure all those assumptions hold, especially for parts of the object graph created dynamically at runtime. &lt;/p&gt;
&lt;h3&gt;CoreData&lt;/h3&gt;
&lt;p&gt;The main difficulty I had was ensuring reliable change notifications when working with FetchResultsController and multiple contexts. Mike Abdullah writes about it here: http://mikeabdullah.net/merging-saved-changes-betwe.html but in short: Any new objects that are merged into a context will only receive future update notifications if they are retained.&lt;/p&gt;
&lt;p&gt;Ultimately it meant merging in new objects was easy, but merging in edits for the same object was tricky. I generally came to the conclusion that any user interaction with managed objects should happen in the shared view context to ensure all FetchResultsControllers can see the change.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Overall I’m still a fan of both frameworks just now slightly more aware of the trade offs involved. 
Swinject is a pleasure to use and Core data, whilst not as charming has first party credentials that make it hard to ignore. &lt;/p&gt;
&lt;p&gt;Regardless, I can't wait to start the next project! &lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ash30/HueInspired"&gt;HueInspired Github Repro&lt;/a&gt;&lt;/p&gt;</summary><category term="Swift"></category><category term="iOS"></category></entry><entry><title>Autolayout Margin anchors vs Dimension anchors</title><link href="http://ashleyarthur.co.uk/autolayout-margin-anchors-vs-dimension-anchors.html" rel="alternate"></link><published>2017-04-17T00:00:00+02:00</published><updated>2017-04-17T00:00:00+02:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2017-04-17:autolayout-margin-anchors-vs-dimension-anchors.html</id><summary type="html">&lt;p&gt;Recently I was testing my custom table cells with dynamic type sizes and even though I didn't have any text present I noticed sub views changing sizes - intrigued, I investigated.&lt;/p&gt;
&lt;p&gt;My cell content was ridiculously simple, just one view that filled the whole parent content view, so what could be going wrong? It turns out it was auto layout related.
When Initially designing the layout I thought of two ways of creating the layout: match the height, width and centres of the parent view OR match horizontal and vertical anchors.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;constraints&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;centerXAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;centerXAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;centerYAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;centerYAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;heightAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;heightAnchor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;widthAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;widthAnchor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;altConstraints&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;span class="n"&gt;stackView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leadingAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leadingAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="n"&gt;stackView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trailingAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trailingAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="n"&gt;stackView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;topAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;topAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="n"&gt;stackView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bottomAnchor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;equalTo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;layoutMarginsGuide&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bottomAnchor&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is a difference though, and it's because I had opted to constrain anchors to the the margin guides. These are actually slightly offset from the edge by UIEdgeInsets and these change based on dynamic type sizes. I believe this is because table cells have the property
&lt;code&gt;self.contentView.preservesSuperviewLayoutMargins&lt;/code&gt; which means table view margin changes are inherited by the cell.&lt;/p&gt;
&lt;p&gt;Ultimately this was a case of view hierarchies and layout constraints can appear the same to the user but there can be subtle differences when interacting with other subsystems.&lt;/p&gt;
&lt;p&gt;On a simpler level, don't overlook your layout margins! &lt;/p&gt;</summary><category term="Swift"></category><category term="AutoLayout"></category></entry><entry><title>Creating Class level Properties in Python</title><link href="http://ashleyarthur.co.uk/creating-class-level-properties-in-python.html" rel="alternate"></link><published>2017-04-02T00:00:00+02:00</published><updated>2017-04-02T00:00:00+02:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2017-04-02:creating-class-level-properties-in-python.html</id><summary type="html">&lt;p&gt;So what happens when you want a computed class property in python? &lt;/p&gt;
&lt;p&gt;Descriptors are invoked via the __getattribute__ so simply assigning a 
descriptor to a class level attribute won't do. Instead you need to 
create the class level property as a instance variable on the classes
type object and rely on the fact attribute look up will eventually
look there via the base classes __class__ attribute.&lt;/p&gt;
&lt;script src="https://gist.github.com/ash30/08ab5a96d7cfb8d5c8fad58ffea93970.js"&gt;&lt;/script&gt;

&lt;p&gt;Obligatory meta class warning: you better be sure you really need todo this :P &lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;http://www.cafepy.com/article/python_attributes_and_methods/python_attributes_and_methods.pdf&lt;/p&gt;</summary><category term="Python"></category></entry><entry><title>Use Unittests to Explore 3rd Party APIs</title><link href="http://ashleyarthur.co.uk/use-unittests-to-explore-3rd-party-apis.html" rel="alternate"></link><published>2017-03-10T00:00:00+01:00</published><updated>2017-03-10T00:00:00+01:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2017-03-10:use-unittests-to-explore-3rd-party-apis.html</id><summary type="html">&lt;p&gt;One of the ideas I've adopted recently is to use unittests to assert the contract between you and a 3rd party API.
It's pretty normal to explore api usage in the REPL but by writing it formally as a series of tests you can record
your findings and review them next time. Even better, you can tests your assumptions if the library ever changes.&lt;/p&gt;
&lt;p&gt;FileIO is always a little platfrom specific, even with cross platform librarys like
python's &lt;code&gt;os.path&lt;/code&gt;. I was tasked recently with porting some tools to windows and found myself
questioning some of my long held assumptions when working with file paths. The obvious question
is what happens with all the backslashes?&lt;/p&gt;
&lt;p&gt;Without futher ado:&lt;/p&gt;
&lt;script src="https://gist.github.com/ash30/cb2e77610bfbd789767ff9eb3ee2d599.js"&gt;&lt;/script&gt;</summary><category term="Python"></category></entry><entry><title>Restoring ViewControllers and their Data sources (WIP)</title><link href="http://ashleyarthur.co.uk/restoring-viewcontrollers-and-their-data-sources-wip.html" rel="alternate"></link><published>2016-11-25T00:00:00+01:00</published><updated>2016-11-25T00:00:00+01:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2016-11-25:restoring-viewcontrollers-and-their-data-sources-wip.html</id><summary type="html">&lt;p&gt;The traditional flow for restoring view controllers in UIKit goes likes this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(Required) Assign restoration identifiers to the view controllers&lt;/li&gt;
&lt;li&gt;(Required) Tell iOS how to create or locate new view controller objects at launch time.&lt;/li&gt;
&lt;li&gt;(Optional) Encode current State for later restoration&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Recreating the hierarchy of view controllers is indeed easy and mostly automated 
but a lot of the articles out there gloss over how to restore their dependencies
(hint: Grabbing references to singletons in the VC’s decodeRestorableState method is not the correct answer!)&lt;/p&gt;
&lt;p&gt;Normally you pass dependencies like a baton between controllers. When restoring a controller,
the segue isn’t called and you get an ‘empty’ controller and its up to you to restore the dependencies.
It turns out the data source can adopt the same state restoring protocol as the view controller and come along for the ride.  &lt;/p&gt;
&lt;h2&gt;Assign restoration ids for dependencies&lt;/h2&gt;
&lt;p&gt;Normally as apart of the app launch you’ll have some code to initialise 
backing data sources for your view controllers. As a small extension to this routine,
we also now have to give them an ID so that the VC’s can indirectly reference them on app restore.&lt;/p&gt;
&lt;p&gt;The app delegate method &lt;strong&gt;willFinishLaunchingWithOptions&lt;/strong&gt; is called after bootstrapping 
but before the restoration process so is a good place to register objects. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;application&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;_&lt;/span&gt; &lt;span class="n"&gt;application&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;UIApplication&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;willFinishLaunchingWithOptions&lt;/span&gt; &lt;span class="n"&gt;launchOptions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;UIApplicationLaunchOptionsKey&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;Any&lt;/span&gt;&lt;span class="p"&gt;]?&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;Bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="c1"&gt;// Register Data Source&lt;/span&gt;

    &lt;span class="bp"&gt;UIApplication&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="n"&gt;forStateRestoration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dataStore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="n"&gt;restorationIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DataSource&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Tell iOS how to create or locate the dependency&lt;/h2&gt;
&lt;p&gt;Any registered dependency must conform to ‘UIStateRestoring’ protocol 
(UIViewControllers automatically conform to this) and allows you to define a restoration class&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;optional&lt;/span&gt; &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nv"&gt;objectRestorationClass&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;UIObjectRestoration&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kr"&gt;get&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you return nil from this method, UIKIT assumes the app startup code recreated 
the dependency already and will be able to find it as you’ve registered it to a restoration id.&lt;/p&gt;
&lt;p&gt;If you do specify a restoration class, it needs to define the following static method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;object&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;withRestorationIdentifierPath&lt;/span&gt; &lt;span class="n"&gt;identifierComponents&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;String&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;coder&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;NSCoder&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="bp"&gt;UIStateRestoring&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It can return a reference to a global, init a new instance or return nil if no restoration is possible. &lt;/p&gt;
&lt;h2&gt;Restoring the Dependency as part of the Controller Decode Process&lt;/h2&gt;
&lt;p&gt;Now when you restore the view controllers state, any request to decode the 
datasources’s restoration id will simply be passed the registered instance.
Voila! You can now reconstruct the VC’s dependencies.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;controller&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;UIViewController&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;

    &lt;span class="kr"&gt;override&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nf"&gt;decodeRestorableState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="bp"&gt;NSCoder&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kc"&gt;super&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decodeRestorableState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;with&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;guard&lt;/span&gt;
            &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;object&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decodeObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;DataSource&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="c1"&gt;// Any &lt;/span&gt;
            &lt;span class="kd"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;dataSource&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="kc"&gt;as&lt;/span&gt;&lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;DateSourceKlass&lt;/span&gt; 
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kc"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dataSource&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dataSource&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The one draw back to this approach, as others have noted, is how it separates 
Controller Restoration and Dependency Restoration into 2 distinct phases. 
You’ve just lost your paddle if you’ve declared your dependencies as const.
I think this hints at UIKits own opinion that controllers don’t actually own 
their datasources and so should be declared weakly.&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developer.apple.com/videos/play/wwdc2013/222/"&gt;https://developer.apple.com/videos/play/wwdc2013/222/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Swift"></category><category term="iOS"></category></entry><entry><title>Note to Unowned Self</title><link href="http://ashleyarthur.co.uk/note-to-unowned-self.html" rel="alternate"></link><published>2016-11-20T00:00:00+01:00</published><updated>2016-11-20T00:00:00+01:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2016-11-20:note-to-unowned-self.html</id><summary type="html">&lt;p&gt;Its easy to think that the answer to all closure woes is to just declare self unowned - no more reference cycles for me!
However this is a very easy way to crash! Been there, done that, never again. &lt;/p&gt;
&lt;p&gt;let me translate what 'unowned' means: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am not the owner of this reference but I am &lt;strong&gt;100%&lt;/strong&gt; sure it will exist when I need it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Said like that, you can see thats a pretty sizeable assumption! &lt;/p&gt;
&lt;p&gt;A Weak reference, most of the time, will be a better bet because it makes you deal with possiblity of nil. &lt;/p&gt;</summary><category term="Swift"></category><category term="iOS"></category></entry><entry><title>Python Bindings for TargetProcess</title><link href="http://ashleyarthur.co.uk/python-bindings-for-targetprocess.html" rel="alternate"></link><published>2016-05-28T00:00:00+02:00</published><updated>2016-05-28T00:00:00+02:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2016-05-28:python-bindings-for-targetprocess.html</id><summary type="html">&lt;p&gt;Where can you find them? In one of my side projects: &lt;a href='https://github.com/ash30/tpapi'&gt;tpapi&lt;/a&gt; - an unoffical python client for TargetProcess. It takes care of interacting with the REST api and returns nice model objects
for you to interact with. Some useful features worth mentioning:&lt;/p&gt;
&lt;h3&gt;Transparent Pagination of Resource Requests&lt;/h3&gt;
&lt;p&gt;Every collection of entities is actually a generator which will lazily send http requests
as needed. This way we can expose a standard iterator interface over paginated resources.&lt;/p&gt;
&lt;h3&gt;Nested Model Lookup&lt;/h3&gt;
&lt;p&gt;For resource or collection attributes we return an iterator over the correct class automatically
so you can continue to chain queries or pluck values.&lt;/p&gt;
&lt;p&gt;Theres also a gist showcasing usage: &lt;a href="https://gist.github.com/ash30/cfebdf200df7e96242755c80c06ade91"&gt;here&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category><category term="RestAPIs"></category></entry><entry><title>Testing Mac Gatekeeper</title><link href="http://ashleyarthur.co.uk/testing-mac-gatekeeper.html" rel="alternate"></link><published>2015-04-29T00:00:00+02:00</published><updated>2015-04-29T00:00:00+02:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2015-04-29:testing-mac-gatekeeper.html</id><summary type="html">&lt;p&gt;Gatekeeper on macOS guards against the execution and installation of applications from unknown sources.
In order to pass this security check an application needs to be correctly signed which means its
a good requirement to check before a release.&lt;/p&gt;
&lt;p&gt;The key gotcha to watch out for when testing is to ensure the executable has been quarantined.
By that I mean it has the ''com.apple.quarantine'' extended attribute present as Gatekeeper 
is triggered specifically at the first time you execute or install a quarantined file.&lt;/p&gt;
&lt;p&gt;To verify the existence of the quarantine flag, you can show 'ls' output in terminal and look
for the '@' at the end of the permission fields. Better yet you can use the 'xattr' command to
show any extended attributes that exist on a file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ xattr /path/to/file

com.apple.quarantine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A programatic method to verify if the application's signature will pass gate keeper is to run the 'spctl' command.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;spctl --assess --type install ./path/to/file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Spctl will exit zero on success or return one if anything failed.&lt;/p&gt;
&lt;p&gt;Additionally you can check the actual signature use 'pkgutil' for futher details.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pkgutil --check-signature ./path/to/file
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Testing"></category><category term="OSX"></category></entry><entry><title>Python Descriptor Notes</title><link href="http://ashleyarthur.co.uk/python-descriptor-notes.html" rel="alternate"></link><published>2014-03-11T00:00:00+01:00</published><updated>2014-03-11T00:00:00+01:00</updated><author><name>Ashley Arthur</name></author><id>tag:ashleyarthur.co.uk,2014-03-11:python-descriptor-notes.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;Descriptors are any object that conform to the descriptor protocol __get__,__set__ and __del__. Properties are a common example&lt;/li&gt;
&lt;li&gt;Descriptors are class level objects and you must use the obj reference passed to it in order to access the parent object.&lt;/li&gt;
&lt;li&gt;This is because the descriptor protocol methods are invoked via an objects __getattribute__ - so be careful when overriding!&lt;/li&gt;
&lt;li&gt;Weirdly hasattr returns false for testing if an class objects holds a specific 
property.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/ash30/cca24018f5153cf51b8c674d3fb94f5f.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="www.docs.python.org/2/howto/descriptor.html"&gt;www.docs.python.org/2/howto/descriptor.html&lt;/a&gt;&lt;/p&gt;</summary><category term="Python"></category></entry></feed>